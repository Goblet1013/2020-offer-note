Serial GC（新生代）：适合单CPU场景下使用
Serial Old GC（老年代）：与Serial GC搭配使用
=============================================================================

ParNew GC（新生代）:Serial GC的多线程版本，适合多CPU场景，与cms搭配使用，与serial old搭配，在某个版本被移除
参数：
--UseParNewGC
========================================================================

Parallel Scavenge GC（JDK8默认使用该GC）（新生代）：吞吐量优先
参数：
--设置并行收集的线程数量
--设置垃圾回收时间占用总时间的比例
--设置自适应调节策略（自动调整年轻代大小，Eden和survivor区比例，晋升老年代年龄等）

ParallelOldGC（老年代）
--二者互相激活，只设置一个参数就可以激活另一个    -XX:+UseParallelGC
=================================================================================

CMS(Current Mark Sweep)（标记-清除）GC（老年代，可以与parnew一起使用）：并发收集，可以与用户线程一起运行，降低STW时间
--流程：初始标记，并发标记，重新标记（标记产生变动的对象），并发清除
--缺点：但是使用标记-清除算法，会导致内存碎片化，加快FULL GC时间
--不会暂停用户线程，但是会降低用户线程运行速度，降低吞吐量
--并发收集，过程中用户线程产生垃圾对象，也就是浮动垃圾，但是不能被本次垃圾回收进行回收，要等到下一次GC回收
参数：
--可以设置堆内存占用比例作为垃圾回收阈值，不能等到内存满了再回收
--设置垃圾回收线程数量
--设置在full gc后对内存进行整理
--设置多少次full gc后堆内存进行整理
==================================================================================

G1（分区算法）:全功能收集器，在延迟可控的情况下获得尽可能高的吞吐量
G1有计划的避免在整个Java堆中进行全区域垃圾收集，跟踪各个region中垃圾堆积的价值大小，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的region

G1面向服务端，主要针对多核CPU以及大容量内存

并行与并发：
--G1回收时可以多个GC线程同时工作，此时用户线程STW
--G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，一般不会完全阻塞应用程序

空间整合：
--G1将内存划分为region，内存回收以region为基本单位，region之间是复制算法，但整体上可看作标记-压缩算法
--G1具有可预测的停顿时间模型，在M毫秒内，垃圾回收时间不超过N毫秒，每次根据允许收集的时间，优先回收价值最大的region

参数：
--UseG1GC
--设置region大小，必须是2的n次方（1MB~32MB）
--最大GC停顿时间，默认200ms
--GC线程数值，最多为8
--并发标记的线程数，设置为GC线程的1/4左右
--设置触发GC的Java堆占用率阈值，默认为45

简单调优步骤：
1.开启G1收集器
2.设置堆最大内存
3.设置最大停顿时间

三个环节：
年轻代GC，
老年代并发标记过程，
混合回收，
如果需要，还存在一个full gc，
对GC的评估失败提供了一种失败保护机制，即强力回收

回收过程：

第一阶段，扫描根。
根连同RSet(Remember Set记录了当前分区被其他分区引用的情况)作为扫描存活对象的入口。

第二阶段，更新RSet。
处理dirty card queue中的card，更新RSet，此阶段完成后，RSet可以准确的反映老年代对所在的内存分段中对象的引用。

第三阶段，处理RSet。
